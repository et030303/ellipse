function runMode2() {
        let b = sqrt(a*a - c*c);
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        noFill(); stroke(180); strokeWeight(3/zoom);
        ellipse(0, 0, 2*a, 2*b);

        // '중심' 항목을 제거한 체크 포인트 배열
        let checkPts = [
            {x: -c, y: 0, label: "F", sub: "₁", prefix: "초점 "},
            {x: c, y: 0, label: "F", sub: "₂", prefix: "초점 "},
            {x: a, y: 0, label: "장축 꼭짓점"},
            {x: -a, y: 0, label: "장축 꼭짓점"},
            {x: 0, y: b, label: "단축 꼭짓점"},
            {x: 0, y: -b, label: "단축 꼭짓점"}
        ];

        let hoveredPt = null;
        for (let pt of checkPts) {
            if (dist(worldMX, worldMY, pt.x, pt.y) < 25/zoom) {
                hoveredPt = pt; break;
            }
        }

        // 시각적 요소 그리기 (중심점 0,0 그리기 코드 삭제)
        fill(100); noStroke();
        ellipse(a, 0, 8/zoom); ellipse(-a, 0, 8/zoom); 
        ellipse(0, b, 8/zoom); ellipse(0, -b, 8/zoom); 
        
        fill(0, 122, 255); ellipse(-c, 0, 15/zoom); ellipse(c, 0, 15/zoom);

        if (hoveredPt) {
            fill(255, 204, 0, 100); noStroke();
            ellipse(hoveredPt.x, hoveredPt.y, 35/zoom); 
            
            fill(0); textSize(15/zoom);
            if (hoveredPt.sub) {
                textAlign(RIGHT, BASELINE); text(hoveredPt.prefix, hoveredPt.x - 10/zoom, hoveredPt.y - 20/zoom);
                drawSubText(hoveredPt.label, hoveredPt.sub, hoveredPt.x + 15/zoom, hoveredPt.y - 20/zoom, 15/zoom);
            } else {
                textAlign(CENTER, BASELINE);
                text(hoveredPt.label, hoveredPt.x, hoveredPt.y - 18/zoom);
            }
        } else {
            drawSubText("F", "₁", -c, -15/zoom, 12/zoom, 100);
            drawSubText("F", "₂", c, -15/zoom, 12/zoom, 100);
        }

        // 거리의 합 표시 로직 (기존과 동일)
        if (mouseIsPressed && !isOverUI() && !hoveredPt) activeAngle = atan2(worldMY, worldMX);

        if (activeAngle !== null) {
            let px = a * cos(activeAngle); let py = b * sin(activeAngle);
            let d1 = dist(px, py, -c, 0); let d2 = dist(px, py, c, 0);

            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(-c, 0, px, py); line(c, 0, px, py);
            fill(34, 197, 94); noStroke(); ellipse(px, py, 12/zoom);
            
            fill(0); textSize(15/zoom); textAlign(CENTER);
            text("d₁: " + d1.toFixed(1), (-c + px)/2, py/2 - 10/zoom);
            text("d₂: " + d2.toFixed(1), (c + px)/2, py/2 - 10/zoom);
            
            fill(255, 59, 48); textSize(18/zoom); textStyle(BOLD);
            text("거리의 합 (d₁ + d₂) = " + (d1+d2).toFixed(1) + " (일정)", 0, -b - 40/zoom);
            textStyle(NORMAL);
        }
    }
